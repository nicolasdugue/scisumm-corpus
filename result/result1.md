##Total Features Number using contrast: 170

### mainpulating the section : 0

1 - **consists**: ,Contrast  ,Feature

2 - **correspond**: ,Contrast  ,Feature

3 - **interpretation**: ,Contrast  ,Feature

4 - **classified**: ,Contrast  ,Feature

5 - **definition**: ,Contrast

6 - **counterparts**: ,Contrast

7 - **one**: ,Contrast  ,Feature

8 - **classes**: ,Contrast  ,Feature

9 - **based**: ,Contrast  ,Feature

10 - **feature-structure**: ,Contrast

11 - **feature-value**: ,Contrast  ,Feature

12 - **Disjunctive**: ,Contrast  ,Feature

13 - **interface**: ,Contrast

14 - **simple**: ,Contrast  ,Feature

15 - **described**: ,Contrast  ,Feature

16 - **basis**: ,Contrast

17 - **treat**: ,Contrast  ,Feature

18 - **formalizations**: ,Contrast  ,Feature

19 - **complex**: ,Contrast  ,Feature

20 - **extended**: ,Contrast  ,Feature

21 - **either**: ,Contrast

22 - **extensions**: ,Contrast  ,Feature

23 - **feature-address**: ,Contrast  ,Feature

### mainpulating the section : 1

1 - **consider**: ,Contrast  ,Feature

2 - **compact**: ,Contrast  ,Feature

3 - **whose**: ,Contrast

4 - **lists**: ,Contrast  ,Feature

5 - **dis**: ,Contrast

6 - **represented**: ,Contrast

7 - **natural**: ,Contrast

8 - **fea**: ,Contrast

9 - **must**: ,Contrast

10 - **example**: ,Contrast  ,Feature

11 - **information**: ,Contrast

12 - **sim**: ,Contrast

13 - **front**: ,Contrast

14 - **mean**: ,Contrast

15 - **fist**: ,Contrast

16 - **descriptions**: ,Contrast  ,Feature  ,Abstract

17 - **language**: ,Contrast

18 - **ture**: ,Contrast

19 - **number**: ,Contrast  ,Feature

20 - **say**: ,Contrast

21 - **take**: ,Contrast  ,Feature

22 - **negative**: ,Contrast  ,Feature  ,Title

23 - **complement**: ,Contrast  ,Feature

24 - **confidence=**: ,Contrast  ,Feature

25 - **values**: ,Contrast  ,Feature  ,Abstract

26 - **finite**: ,Contrast  ,Feature

27 - **possible**: ,Contrast

28 - **using**: ,Contrast  ,Feature

29 - **agreement**: ,Contrast  ,Feature  ,Abstract

30 - **specifies**: ,Contrast

31 - **describe**: ,Contrast  ,Feature

32 - **allowing**: ,Contrast

33 - **disjunctions**: ,Contrast

### mainpulating the section : 2

1 - **address**: ,Contrast  ,Feature

2 - **type**: ,Contrast  ,Feature  ,Abstract

3 - **said**: ,Contrast

4 - **tag**: ,Contrast  ,Feature

5 - **feature**: ,Contrast  ,Feature  ,Abstract

6 - **order**: ,Contrast  ,Feature

7 - **denotes**: ,Contrast  ,Feature

8 - **term**: ,Contrast  ,Feature  ,Abstract

9 - **subset**: ,Contrast

10 - **domains**: ,Contrast  ,Feature

11 - **denoted**: ,Contrast  ,Feature

12 - **occurs**: ,Contrast

13 - **least**: ,Contrast

14 - **dlist**: ,Contrast  ,Feature

15 - **relation**: ,Contrast  ,Feature

16 - **set**: ,Contrast  ,Feature

17 - **written**: ,Contrast

18 - **apos**: ,Contrast  ,Feature  ,Abstract

19 - **assigning**: ,Contrast

20 - **finite**: ,Contrast  ,Feature

21 - **disagreements**: ,Contrast  ,Feature

22 - **called**: ,Contrast  ,Feature

23 - **defined**: ,Contrast  ,Feature

24 - **symbol**: ,Contrast  ,Feature  ,Abstract

25 - **inhibited**: ,Contrast

### mainpulating the section : 3

1 - **AuG**: ,Contrast

2 - **subsumption**: ,Contrast  ,Feature

3 - **graph**: ,Contrast  ,Feature

4 - **join**: ,Contrast  ,Feature

5 - **upper**: ,Contrast

6 - **implemented**: ,Contrast  ,Feature

7 - **method**: ,Contrast  ,Feature

8 - **bol**: ,Contrast

9 - **put**: ,Contrast

10 - **gives**: ,Contrast

11 - **two**: ,Contrast  ,Feature

12 - **meet**: ,Contrast  ,Feature

13 - **mented**: ,Contrast

14 - **order**: ,Contrast  ,Feature

15 - **maximal**: ,Contrast

16 - **operation**: ,Contrast  ,Feature

17 - **Given**: ,Contrast  ,Feature

18 - **consisting**: ,Contrast

19 - **manner**: ,Contrast

20 - **also**: ,Contrast  ,Feature

21 - **pairs**: ,Contrast

22 - **set**: ,Contrast  ,Feature

23 - **arc**: ,Contrast  ,Feature

24 - **apos**: ,Contrast  ,Feature  ,Abstract

25 - **complement**: ,Contrast  ,Feature

26 - **define**: ,Contrast

27 - **func**: ,Contrast

28 - **thesame**: ,Contrast

29 - **lower**: ,Contrast

30 - **lattice**: ,Contrast  ,Feature  ,Abstract

31 - **unification**: ,Contrast  ,Feature  ,Abstract

32 - **i.e.**: ,Contrast

### mainpulating the section : 4

1 - **logic-based**: ,Contrast  ,Feature

2 - **include**: ,Contrast  ,Feature

3 - **neg**: ,Contrast  ,Feature

4 - **method**: ,Contrast  ,Feature

5 - **use**: ,Contrast  ,Feature

6 - **descrip**: ,Contrast  ,Feature

7 - **information**: ,Contrast  ,Feature

8 - **typed**: ,Contrast  ,Feature

9 - **Data**: ,Contrast  ,Feature

10 - **allow**: ,Contrast  ,Feature

11 - **developed**: ,Contrast  ,Feature

12 - **negations**: ,Contrast  ,Feature  ,Abstract

13 - **paper**: ,Contrast  ,Feature  ,Abstract

14 - **existences**: ,Contrast  ,Feature  ,Abstract

15 - **scriptions**: ,Contrast  ,Feature

16 - **used**: ,Contrast  ,Feature

17 - **descriptions**: ,Contrast  ,Feature  ,Abstract

18 - **shown**: ,Contrast  ,Feature

19 - **formation**: ,Contrast  ,Feature

20 - **representing**: ,Contrast  ,Feature

21 - **kinds**: ,Contrast  ,Feature

22 - **tion**: ,Contrast  ,Feature

23 - **treated**: ,Contrast  ,Feature

24 - **generalization**: ,Contrast  ,Feature

25 - **efficient**: ,Contrast  ,Feature

26 - **also**: ,Contrast  ,Feature

27 - **extending**: ,Contrast  ,Feature

28 - **ative**: ,Contrast  ,Feature

29 - **tures**: ,Contrast  ,Feature

30 - **based**: ,Contrast  ,Feature

31 - **negative**: ,Contrast  ,Feature  ,Title

32 - **struc**: ,Contrast  ,Feature

33 - **described**: ,Contrast  ,Feature

34 - **three**: ,Contrast  ,Feature

35 - **treat**: ,Contrast  ,Feature

36 - **linguistic**: ,Contrast  ,Feature

37 - **formalizations**: ,Contrast  ,Feature

38 - **values**: ,Contrast  ,Feature  ,Abstract

39 - **promising**: ,Contrast  ,Feature

40 - **formalism**: ,Contrast  ,Feature

41 - **make**: ,Contrast  ,Feature

42 - **gorithms**: ,Contrast  ,Feature

43 - **obtain**: ,Contrast  ,Feature

44 - **easy**: ,Contrast  ,Feature

45 - **using**: ,Contrast  ,Feature

46 - **introduces**: ,Contrast  ,Feature

47 - **feature-address**: ,Contrast  ,Feature

48 - **structures**: ,Contrast  ,Feature  ,Abstract

49 - **algorithm**: ,Contrast  ,Feature  ,Abstract

50 - **augmented**: ,Contrast  ,Feature

### mainpulating the section : 5

1 - **Research**: ,Contrast  ,Feature

##Total Features Number : 163

### mainpulating the section : 0

1 - **consists** ,Feature

2 - **type** ,Feature  ,Abstract

3 - **feature** ,Feature  ,Abstract

4 - **correspond** ,Feature

5 - **interpretation** ,Feature

6 - **negations** ,Feature  ,Abstract

7 - **framework** ,Feature

8 - **classified** ,Feature

9 - **descriptions** ,Feature  ,Abstract

10 - **one** ,Feature

11 - **classes** ,Feature

12 - **based** ,Feature

13 - **negative** ,Feature  ,Title

14 - **feature-value** ,Feature

15 - **Disjunctive** ,Feature

16 - **apos** ,Feature  ,Abstract

17 - **simple** ,Feature

18 - **described** ,Feature

19 - **three** ,Feature

20 - **treat** ,Feature

21 - **linguistic** ,Feature

22 - **formalizations** ,Feature

23 - **tions** ,Feature

24 - **complex** ,Feature

25 - **extended** ,Feature

26 - **lattice** ,Feature  ,Abstract

27 - **objects** ,Feature

28 - **extensions** ,Feature

29 - **describe** ,Feature

30 - **feature-address** ,Feature

### mainpulating the section : 1

1 - **consider** ,Feature

2 - **compact** ,Feature

3 - **lists** ,Feature

4 - **example** ,Feature

5 - **descriptions** ,Feature  ,Abstract

6 - **number** ,Feature

7 - **take** ,Feature

8 - **negative** ,Feature  ,Title

9 - **complement** ,Feature

10 - **linguistic** ,Feature

11 - **confidence=** ,Feature

12 - **understand** ,Feature

13 - **values** ,Feature  ,Abstract

14 - **make** ,Feature

15 - **complex**: ,Contrast  ,Feature

16 - **finite** ,Feature

17 - **using** ,Feature

18 - **agreement** ,Feature  ,Abstract

19 - **describe** ,Feature

20 - **grammatical** ,Feature

### mainpulating the section : 2

1 - **address** ,Feature

2 - **type** ,Feature  ,Abstract

3 - **tag** ,Feature

4 - **feature** ,Feature  ,Abstract

5 - **order** ,Feature

6 - **denotes** ,Feature

7 - **term** ,Feature  ,Abstract

8 - **domains** ,Feature

9 - **denoted** ,Feature

10 - **first** ,Feature

11 - **dlist** ,Feature

12 - **relation** ,Feature

13 - **set** ,Feature

14 - **apos** ,Feature  ,Abstract

15 - **finite**: ,Contrast  ,Feature

16 - **disagreements** ,Feature

17 - **function** ,Feature

18 - **called** ,Feature

19 - **defined** ,Feature

20 - **symbol** ,Feature  ,Abstract

21 - **structures** ,Feature  ,Abstract

22 - **augmented** ,Feature

### mainpulating the section : 3

1 - **subsumption** ,Feature

2 - **graph** ,Feature

3 - **join** ,Feature

4 - **implemented** ,Feature

5 - **method** ,Feature

6 - **two** ,Feature

7 - **type**: ,Contrast  ,Feature  ,Abstract

8 - **meet** ,Feature

9 - **quot** ,Feature

10 - **elements** ,Feature

11 - **order**: ,Contrast  ,Feature

12 - **operation** ,Feature

13 - **Given** ,Feature

14 - **also** ,Feature

15 - **take**: ,Contrast  ,Feature

16 - **inconsistency** ,Feature

17 - **set**: ,Contrast  ,Feature

18 - **arc** ,Feature

19 - **apos**: ,Contrast  ,Feature  ,Abstract

20 - **complement**: ,Contrast  ,Feature

21 - **amp** ,Feature

22 - **lattice** ,Feature  ,Abstract

23 - **unification** ,Feature  ,Abstract

### mainpulating the section : 4

1 - **logic-based** ,Feature

2 - **compact**: ,Contrast  ,Feature

3 - **include** ,Feature

4 - **neg** ,Feature

5 - **method**: ,Contrast  ,Feature

6 - **use** ,Feature

7 - **descrip** ,Feature

8 - **compactly** ,Feature

9 - **example**: ,Contrast  ,Feature

10 - **information**: ,Contrast  ,Feature

11 - **subcat** ,Feature

12 - **typed** ,Feature

13 - **Data** ,Feature

14 - **allow** ,Feature

15 - **developed** ,Feature

16 - **negations** ,Feature  ,Abstract

17 - **paper** ,Feature  ,Abstract

18 - **existences** ,Feature  ,Abstract

19 - **easier** ,Feature

20 - **scriptions** ,Feature

21 - **used** ,Feature

22 - **descriptions**: ,Contrast  ,Feature  ,Abstract

23 - **shown** ,Feature

24 - **formation** ,Feature

25 - **representing** ,Feature

26 - **kinds** ,Feature

27 - **tion** ,Feature

28 - **treated** ,Feature

29 - **debugging** ,Feature

30 - **generalization** ,Feature

31 - **efficient** ,Feature

32 - **also**: ,Contrast  ,Feature

33 - **extending** ,Feature

34 - **ative** ,Feature

35 - **tures** ,Feature

36 - **relation**: ,Contrast  ,Feature

37 - **based**: ,Contrast  ,Feature

38 - **negative**: ,Contrast  ,Feature  ,Title

39 - **struc** ,Feature

40 - **complement**: ,Contrast  ,Feature

41 - **described**: ,Contrast  ,Feature

42 - **three** ,Feature

43 - **treat**: ,Contrast  ,Feature

44 - **linguistic** ,Feature

45 - **formalizations**: ,Contrast  ,Feature

46 - **values**: ,Contrast  ,Feature  ,Abstract

47 - **promising** ,Feature

48 - **formalism** ,Feature

49 - **make** ,Feature

50 - **gorithms** ,Feature

51 - **obtain** ,Feature

52 - **easy** ,Feature

53 - **using**: ,Contrast  ,Feature

54 - **unification-based** ,Feature

55 - **introduces** ,Feature

56 - **primitive** ,Feature

57 - **describe**: ,Contrast  ,Feature

58 - **feature-address**: ,Contrast  ,Feature

59 - **structures** ,Feature  ,Abstract

60 - **algorithm** ,Feature  ,Abstract

61 - **augmented** ,Feature

### mainpulating the section : 5

1 - **Research** ,Feature

#The Summary
**ze take 5 percent of the important and long sentences for making the summary**

OF COLING92, NANTES, AuG, 2328, 1992 This paper proposes an extension to Aithaci&apos;sV&apos; type that incorporates three kinds of the primitive negative descriptions described below into the 0-type.

In this paper, both these type structures and the type symbol lattice on which term structures are definedare extended to treat negative descriptions.

</sectionHeader> <subsectionHeader confidence="0.434954"> Descriptions of TFSs </subsectionHeader> <bodyText confidence="0.971192533333333">In describing linguistic information using (typed) feature structures, negative descriptions make the description compact, intuitive, and hence easy to understand.

Definition 4 A term is a triple (Ar, v) where A is a term domain on .F, r is a type symbol function from .7 to T such that r(T* â A) = IT), and v is a tag symbol function from A to V. Given a tag symbol function v, Addl.., denotes the function from a tag symbol to the set of addresses: Addr,(X) := Al v(p) = X}.

The set 14./Y7&apos; of well-formed terms includes many terms that have the same type symbol function, the same coreference relations, the same inhibited featurefunction, and the same disagreement address func tion but different tag symbol functions.

a AT b = c if and only if lain 114 = A feature symbol denotes a function from a subset of U to U. A feature path is a finite string of feature symbols and denotes the function obtained by the composition of the functions that the feature symbols denote.

A subdomain of a term domain, corresponding to a subgraph, is defined as follows, Definition 3 Given a term domain A and a feature address p E A, the subdomain of A at p is defined to be the term domain A/p := {P&apos; I P â¢ P&apos; E A}.

AltKaci&apos;s term structure, the basis of the tit-type, is defined by assigning a type symbol and a tag symbol to each feature address as follows.

2328, 1992 node structure 111=111111110M11= rinIMINI/a set o arc structures 11=121111111= IEZZEINIMINI=ED 011=1111111111=12=11M011â 1 MIIIIIIIIIMIEMIE 1/4=11â¢1111ELIMMTIM 111121MIMICIIMEDIEED Figure 4: Data Structures Function Unify(nodel , nodc2) begin node] := Dereference(nodel); riode2 :-= Dereference(ruxle2); if node] = node then return( node 1); nodel . forward := node2 ; node2.tsymbol := node] .tsurnbol AT node2.tsymbol; if node2.tsymbol = _I_ then return(i) node2.ileatures node] .ifeatures U node2 :ilea tures ; if node2.ifeaturesn { arc. feature I arc E node] .arcs U node .nrcs) 0 then returri(1.); node2.dnodes := node!

.arcs ::= arcs U node . arcs; ovturn(node2); end Figure 5: A Destructive Graph Unification Functionso that a covers an additional type symbol.

In this paper, FSs have been augmented, using a promising method of for AltKaci&apos;s type, to allow three kinds of negative descriptions of them to be treated.In a formalization of typed feature structures, neg ative descriptions can be decomposed into three kinds of negations: negations of type symbols, negations of feature existences, and negations of feature-address value agreements.


/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/scipy/spatial/distance.py:287: RuntimeWarning: invalid value encountered in double_scalars
  dist = 1.0 - np.dot(u, v) / (norm(u) * norm(v))

#analysing the annotation 1

##The Citing Sentences :
While an improvement over simple destructive unification, Tomabechi's approach still suffers from what Kogure (Kogure, 1990) calls redundant copying.

###The Corpus Reference Sentences :
1.0


**21** : itowever, the problem with his method is that a unitication result graph consists only of newly created structures.

1.0


**22** : This is unnecessary because there are often input snbgraphs that can be used as part of the result graph without any modification, or as sharable parts between one of the input graphs and the result graph.

0.98827166792


**23** : Copying sharable parts is called redundant copying.


###Our Reference Sentences :
0.257253382033

**194** : Unification The unification operation for augmented tk-terms or augmented TFSs has been implemented using graphunification techniques.


0.316278989552

**213** : To simplify the explanation, the destructive version of graph unification is used above.


0.360849090372

**214** : Other versions based on more efficient graph unification methods such as Wroblewski's and Kogure's method [23, 16) have also been developed.


0.366603940438

**215** : Furthermore, it is easy to modify other graph unification inethods[21, 61 to allow augmented 1TSs.


0.400128494568

**196** : The unification oper ation for such DGs corresponds to a graph merging operation.



#analysing the annotation 2

##The Citing Sentences :
The extension is classified into class (1) above.Based on this paper's formalization, unification algorithms have been developed using graph unification techniques[23, 16].

###The Corpus Reference Sentences :
0.372468353304


**0** : Strategic Lazy Incremental Copy Graph Unification


###Our Reference Sentences :
0.252788071412

**44** : The extension is classified into class (1) above.Based on this paper's formalization, unification al gorithms have been developed using graph unificationtechniques[23, 16].


0.452815742089

**198** : In a destructive graph unification method, winch is very simple, such a graph is represented by the data structures in Figure 4.


0.483832312905

**213** : To simplify the explanation, the destructive version of graph unification is used above.


0.503475594639

**214** : Other versions based on more efficient graph unification methods such as Wroblewski's and Kogure's method [23, 16) have also been developed.


0.50531293874

**194** : Unification The unification operation for augmented tk-terms or augmented TFSs has been implemented using graphunification techniques.



#analysing the annotation 3

##The Citing Sentences :
Other versions based on more efficient graph unification methods such as Wroblewski's and Kogure's method [23, 16] have also been developed.

###The Corpus Reference Sentences :
0.196785800727


**0** : Strategic Lazy Incremental Copy Graph Unification


###Our Reference Sentences :
0.110528439076

**214** : Other versions based on more efficient graph unification methods such as Wroblewski's and Kogure's method [23, 16) have also been developed.


0.187257215387

**198** : In a destructive graph unification method, winch is very simple, such a graph is represented by the data structures in Figure 4.


0.207188896699

**213** : To simplify the explanation, the destructive version of graph unification is used above.


0.258009369345

**215** : Furthermore, it is easy to modify other graph unification inethods[21, 61 to allow augmented 1TSs.


0.29728164565

**196** : The unification oper ation for such DGs corresponds to a graph merging operation.



#analysing the annotation 4

##The Citing Sentences :
This is inefficient with many copy operations due to unfications of unnecessary features that do not contribute to successful unification [6].

###The Corpus Reference Sentences :
0.741512481829


**205** : Furthermore, structure sharing increases the portion of token identical substructures of FSs which makes it efficient to keep unification results of substructures of FSs and reuse them.

1.0


**206** : This reduces repeated calculation of substructures.


###Our Reference Sentences :
0.189267211423

**76** : OF COLING92, NANTES, AUG. 2328, 1992 3.1 Typed Feature Structures as.


0.208989686868

**146** : Such an inconsistency is called a feature inconsistency.


0.247694927216

**156** : This is also true for feature incon sistency and tag inconsistency.


0.291551305299

**73** : &apos;Fenn structures are first augmented with structures representing in features and disagreement of feature address values.


0.33239976086

**22** : In order to treat feature domains of complex FSsand to treat taxonomic hierarchies of symbolic feature values, type (or sort) hierarchies have been in troduced, allowing definition of typed (or sorted) feature-structures (Ms).



##The Citing Sentences :
Thus treatments such as strategic unification [6] have been developed.

###The Corpus Reference Sentences :
0.535066559359


**205** : Furthermore, structure sharing increases the portion of token identical substructures of FSs which makes it efficient to keep unification results of substructures of FSs and reuse them.

1.0


**206** : This reduces repeated calculation of substructures.


###Our Reference Sentences :
0.189267211423

**76** : OF COLING92, NANTES, AUG. 2328, 1992 3.1 Typed Feature Structures as.


0.208989686868

**146** : Such an inconsistency is called a feature inconsistency.


0.247694927216

**156** : This is also true for feature incon sistency and tag inconsistency.


0.291551305299

**73** : &apos;Fenn structures are first augmented with structures representing in features and disagreement of feature address values.


0.306093482112

**194** : Unification The unification operation for augmented tk-terms or augmented TFSs has been implemented using graphunification techniques.



#analysing the annotation 5

##The Citing Sentences :
This observation is the basis for a reordering method proposed by Kogure [1990].

###The Corpus Reference Sentences :
0.938725440995


**3** : The other, called ti~e strategic incremental copy graph unification method, uses an early failure finding strategy which first tries to unify ;ubstructures tending to fail in unification; this method is; based on stochastic data on tim likelihood of failure and ,'educes unnecessary computation.


###Our Reference Sentences :
0.693518079786

**46** : </bodyText> <sectionHeader confidence="0.650502" genericHeader="method">


0.819102083449

**221** : It is also shown that the first kind can be treated by extending type symbol lattices to include complement type symbols.&apos;Die proposed formalization can provide efficient al AcrEs 05 COLING92, NANTES, 2328 Â°art 1992 3 8 5 PROC.


0.822609093578

**216** : This paper has proposed an augmentation of feature structures (FSs) which introduces negative in formation into FSs in unification-based formalisms.Unification-based linguistic formalisms use lbs to describe linguistic objects and phenomena.


0.849810928954

**214** : Other versions based on more efficient graph unification methods such as Wroblewski's and Kogure's method [23, 16) have also been developed.


0.930390015386

**198** : In a destructive graph unification method, winch is very simple, such a graph is represented by the data structures in Figure 4.



#analysing the annotation 6

##The Citing Sentences :
Thus for any automatic counting scheme some constant shuffling and reshuffling of the conjunct order needs to be applied until the order stabilizes (see also [Kogure 1990]).

###The Corpus Reference Sentences :
1.0


**186** : in this method, theretbre, the failure tendency information is acquired by a learning process.

1.0


**187** : That is, the SING unification method applied in an analysis system uses the failure tendency information acquired by a learning analysis process.

0.831321566047


**188** : in the learning process, when FS unification is applied, feature treatment orders are randomized for the sake of random extraction.


###Our Reference Sentences :
0.608409923362

**170** : The subsumption order on IP are defined by [Ii] &lt; [12] if ti &lt;12 is well-defined.Lattice operations on P can be defined to be com patible with the above subsumption order relation as follows.


0.722156793484

**162** : The subsumption orders on W.TT and on sP are defined as follows.


0.831896953137

**204** : The func tion finally treats arcs in order to make the result graph right-congruent.


0.914109398202

**214** : Other versions based on more efficient graph unification methods such as Wroblewski's and Kogure's method [23, 16) have also been developed.


0.918161073677

**81** : a partial order &lt;7 on T such that (a) I. is the least and T is the greatest element, and (b) every pair of type symbols a, b E 7 have a least upper bound or join, which is denoted by a VT b and a greatest lower bound or meet, which is denoted by a AT b, 3.



#analysing the annotation 7

##The Citing Sentences :
The lazy copying approach ([Kogure, 1990], and [Emele, 1991] for lazy copying in TFS with historical backtracking) copies only overlapping parts of the structure.

###The Corpus Reference Sentences :
0.602810230776


**39** : This paper proposes an FS unification method that allows structure sharing with constant m'der node access time.

0.389203132111


**40** : This method achieves structure sharing by introducing lazy copying to Wroblewski's incremental copy graph unification method.

1.0


**78** : Then, the unification of tl anti t2 is defined as their greatest lower bound or the meet.


###Our Reference Sentences :
0.340587698531

**28** : Asubsumption relation is defined on these term structures.


0.600125758346

**216** : This paper has proposed an augmentation of feature structures (FSs) which introduces negative in formation into FSs in unification-based formalisms.Unification-based linguistic formalisms use lbs to describe linguistic objects and phenomena.


0.610726685479

**195** : A term structure is repre sented as a directed graph by assigning a graph nodeto each K-class as in Figure 2.


0.615352214286

**224** : Logic-based frameworks can be used to obtain the data structures for this paper&apos;s formalization.Unification algorithms for augmented terms or augmented TFSs have been developed using graph uni fication techniques.


0.640794453742

**219** : It is shown that the second andthird kinds can be treated by augmenting term struc tures to include structures representing such kinds of descriptions.



#analysing the annotation 8

##The Citing Sentences :
At least two schemes have been proposed recently ])a.~ed Ul)OU this observation (namely [Kogure.

###The Corpus Reference Sentences :
1.0


**0** : Strategic Lazy Incremental Copy Graph Unification


###Our Reference Sentences :
0.346568857752

**197** : This takes two DGs and merges hi-classes of the same feature-address into a K-class.


0.700634007608

**205** : For treating arcs, the function Unify assumes two functions, Shared_Arc_Pairs and Comylemeni_Arcs.


0.768489671184

**202** : The function Unify takes two input nodes and puts them in a K.-class by letting one input be the forward field values.


0.776883638935

**211** : Unification of two nodes which have each other in their dnodes yields 1 because of tag inconsistency.


0.784524304089

**201** : By traversing two DGs&apos; nodeswith the same feature-address simultaneously, calcu lating the union of their K-classes, and copying arcs, their unification can be calculated as in Figure 5.



##The Citing Sentences :
1990] and [Emele, 1991]); however, both schemes are I)ased upon the increlllent'al Col)yiug sehellle all(l ~-LS ([e- scribed in [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi'om Early Copying as defined in that article.

###The Corpus Reference Sentences :
1.0


**0** : Strategic Lazy Incremental Copy Graph Unification


###Our Reference Sentences :
0.108417539493

**79** : A signature is formally defined as follows, Definition 1 A signature is a quadruple (7, &lt;7 V) consisting of: 1.


0.155756545699

**162** : The subsumption orders on W.TT and on sP are defined as follows.


0.287115075692

**142** : To treat, such inconsistency, a relation 41 on 311.1.TY is defined as follows.


0.300727075056

**149** : lien cc, the three kinds of inconsistency are treatedintegratedly by a relation ff on W.FT defined as fol lows.


0.315979425779

**72** : Next, augmented 0,-terms and 0-types are defined.



#analysing the annotation 9
**Not valid annotation**

#analysing the annotation 10

##The Citing Sentences :
2In the large-scale HPSG-based spoken Japanese analysis system developed at ATR, sometimes 98 percent of the elapsed time is devoted to graph unification ([Kogure, 1990]).

###The Corpus Reference Sentences :
0.551774868036


**205** : Furthermore, structure sharing increases the portion of token identical substructures of FSs which makes it efficient to keep unification results of substructures of FSs and reuse them.


###Our Reference Sentences :
0.105780837112

**213** : To simplify the explanation, the destructive version of graph unification is used above.


0.129352844443

**198** : In a destructive graph unification method, winch is very simple, such a graph is represented by the data structures in Figure 4.


0.13981124891

**214** : Other versions based on more efficient graph unification methods such as Wroblewski's and Kogure's method [23, 16) have also been developed.


0.147556301315

**215** : Furthermore, it is easy to modify other graph unification inethods[21, 61 to allow augmented 1TSs.


0.192674666812

**196** : The unification oper ation for such DGs corresponds to a graph merging operation.



#analysing the annotation 11

##The Citing Sentences :
That is, unless some new scheme for reducing excessive copying is introduced such as scucture-sharing of an unchanged shared-forest ([Kogure, 1990]).

###The Corpus Reference Sentences :
1.0


**11** : For example, a spoken Present.

1.0


**14** : Japanese analysis system based on llPSG[Kogure 891 uses 90% - 98% of the elapsed time in FS unification.


###Our Reference Sentences :
0.976475805018

**201** : By traversing two DGs&apos; nodeswith the same feature-address simultaneously, calcu lating the union of their K-classes, and copying arcs, their unification can be calculated as in Figure 5.


0.984701775366

**183** : Let A : fat, , aN1 be the set of atoms of 7, that is, type symbols which cover 1.4 If there arenon-atomic type symbols which cover only one sym bol, for each such symbol a, a new atom is added &apos;A lattice is called complemented if its all elements have complements.[3] &apos;a is said to cover 13 if b &lt;7 a and b &lt;7 c &lt;-r a implies c = b. r1(p) VT T2(P), (10c) 01(P) n 02(0, and (10d) -{u3(q) I q E (Disagrâ,,,(p) (Oil.


0.995311403785

**107** : (8) XEx(p) Augmented terms are hereafter referred to simply as terms unless stated otherwise.


1.0

**216** : This paper has proposed an augmentation of feature structures (FSs) which introduces negative in formation into FSs in unification-based formalisms.Unification-based linguistic formalisms use lbs to describe linguistic objects and phenomena.


1.0

**217** : Because lin guistic information can be described compactly usingdisjunctive and negative descriptions, l&apos;Ss and feature descriptions are required to treat such descrip tions.



#analysing the annotation 12

##The Citing Sentences :
A more eNcient unification algorithm would avoid this redundant copying (copying structures that can be shared by the input and resultant graphs) (Kogure, 1990).

###The Corpus Reference Sentences :
0.626854626035


**203** : The LING unification method achieves structure sharing without the O(log d) data access overhead of Pereira's method.

0.806070665642


**22** : This is unnecessary because there are often input snbgraphs that can be used as part of the result graph without any modification, or as sharable parts between one of the input graphs and the result graph.

0.992842676709


**23** : Copying sharable parts is called redundant copying.

0.14122177722


**24** : A better method would nfinimize the copying of sharable varts.


###Our Reference Sentences :
0.563125180363

**198** : In a destructive graph unification method, winch is very simple, such a graph is represented by the data structures in Figure 4.


0.63847450896

**195** : A term structure is repre sented as a directed graph by assigning a graph nodeto each K-class as in Figure 2.


0.679174439799

**213** : To simplify the explanation, the destructive version of graph unification is used above.


0.691383779949

**214** : Other versions based on more efficient graph unification methods such as Wroblewski's and Kogure's method [23, 16) have also been developed.


0.694162529142

**215** : Furthermore, it is easy to modify other graph unification inethods[21, 61 to allow augmented 1TSs.



#analysing the annotation 13

##The Citing Sentences :
Kogure (1990) proposed a lazy incremental copy graph (LING) unification that uses dependency-directed eol)yiug

###The Corpus Reference Sentences :
0.577952603397


**22** : This is unnecessary because there are often input snbgraphs that can be used as part of the result graph without any modification, or as sharable parts between one of the input graphs and the result graph.

1.0


**23** : Copying sharable parts is called redundant copying.

1.0


**24** : A better method would nfinimize the copying of sharable varts.


###Our Reference Sentences :
0.104078318392

**213** : To simplify the explanation, the destructive version of graph unification is used above.


0.128084978437

**198** : In a destructive graph unification method, winch is very simple, such a graph is represented by the data structures in Figure 4.


0.138173521256

**214** : Other versions based on more efficient graph unification methods such as Wroblewski's and Kogure's method [23, 16) have also been developed.


0.145933319595

**215** : Furthermore, it is easy to modify other graph unification inethods[21, 61 to allow augmented 1TSs.


0.191137586698

**196** : The unification oper ation for such DGs corresponds to a graph merging operation.



#analysing the annotation 14

##The Citing Sentences :
A better method would avoid (eliminate) such redundant copying as it is called by [Kogure 90].

###The Corpus Reference Sentences :
0.838820857068


**23** : Copying sharable parts is called redundant copying.

0.0127365961007


**24** : A better method would nfinimize the copying of sharable varts.


###Our Reference Sentences :
0.672021143327

**227** : The author would like to thank Ikuo Takeuchi, Akira Shimazu, Shozo Naito, Masahito Kawamori, Mikio Nakano, and other colleagues of the group for their encouragement and thought-provoking discussions.


0.884851444188

**117** : here, a is an equivalence relation and a a class is called a coreference class.


0.935717171708

**148** : Such an inconsistency is called a tag inconsistency.


0.945658648469

**46** : </bodyText> <sectionHeader confidence="0.650502" genericHeader="method">


0.946151535547

**141** : Such an inconsistency is called a type inconsis tency.



#analysing the annotation 15

##The Citing Sentences :
Similarly, in Kogure's approach, not all redundant copying is avoided in cases where there exists a feature path (a sequence of nodes connected by arcs) to a node that needs to be copied.

###The Corpus Reference Sentences :
0.996204650874


**23** : Copying sharable parts is called redundant copying.

0.998259446999


**141** : 5 disables structure sharing, ttowever, this whole copying is not necessary if a lazy evaluation method is used.

0.218413943414


**142** : With such a method, it is possible to delay copying a node until either its own contents need to change (e.g., node G3/Ka c !7>) or until it is found to have an arc (sequence) to a node t, hat needs to be copied (e.g., node X G3/<a c> in Fig.


###Our Reference Sentences :
0.0739843836484

**187** : 2328, 1992 node structure 111=111111110M11= rinIMINI/a set o arc structures 11=121111111= IEZZEINIMINI=ED 011=1111111111=12=11M011â 1 MIIIIIIIIIMIEMIE 1/4=11â¢1111ELIMMTIM 111121MIMICIIMEDIEED Figure 4: Data Structures Function Unify(nodel , nodc2) begin node] := Dereference(nodel); riode2 :-= Dereference(ruxle2); if node] = node then return( node 1); nodel . forward := node2 ; node2.tsymbol := node] .tsurnbol AT node2.tsymbol; if node2.tsymbol = _I_ then return(i) node2.ileatures node] .ifeatures U node2 :ilea tures ; if node2.ifeaturesn { arc. feature I arc E node] .arcs U node .nrcs) 0 then returri(1.); node2.dnodes := node!


0.190525073731

**188** : .dnodes U node2.dnodes; if {nodel , node2} fl node2.dnodes tt then rettirn(..t.); arcpairs := Shared _Arc_Pairs(nodel , node2); for (arc] , arc2) in Â°repairs do begin value := Unify(orcl :value, arc2.value); if value -= then return(Â±); end; arcs := Coroplement_Ares(node I , node!]); node!]


0.196429217588

**207** : The function Complemenl_A re S also takes two nodes and gives a set of arcs whose features exist in the first node but not in the second.


0.213258102765

**209** : When unification of two nodes results in a node with an arc with a feature in ifeatures, it yields I because of feature inconsistency.


0.305319111609

**208** : An inhibited feature function is implemented using the gestures field of nodes.



##The Citing Sentences :
As it has been noticed by [Godden 90] and [Kogure 90], the key idea of avoiding "redundant copying" is to do copying lazily.

###The Corpus Reference Sentences :
0.776127635796


**23** : Copying sharable parts is called redundant copying.

0.896300603643


**141** : 5 disables structure sharing, ttowever, this whole copying is not necessary if a lazy evaluation method is used.

0.96847569508


**142** : With such a method, it is possible to delay copying a node until either its own contents need to change (e.g., node G3/Ka c !7>) or until it is found to have an arc (sequence) to a node t, hat needs to be copied (e.g., node X G3/<a c> in Fig.


###Our Reference Sentences :
0.0739843836484

**187** : 2328, 1992 node structure 111=111111110M11= rinIMINI/a set o arc structures 11=121111111= IEZZEINIMINI=ED 011=1111111111=12=11M011â 1 MIIIIIIIIIMIEMIE 1/4=11â¢1111ELIMMTIM 111121MIMICIIMEDIEED Figure 4: Data Structures Function Unify(nodel , nodc2) begin node] := Dereference(nodel); riode2 :-= Dereference(ruxle2); if node] = node then return( node 1); nodel . forward := node2 ; node2.tsymbol := node] .tsurnbol AT node2.tsymbol; if node2.tsymbol = _I_ then return(i) node2.ileatures node] .ifeatures U node2 :ilea tures ; if node2.ifeaturesn { arc. feature I arc E node] .arcs U node .nrcs) 0 then returri(1.); node2.dnodes := node!


0.190525073731

**188** : .dnodes U node2.dnodes; if {nodel , node2} fl node2.dnodes tt then rettirn(..t.); arcpairs := Shared _Arc_Pairs(nodel , node2); for (arc] , arc2) in Â°repairs do begin value := Unify(orcl :value, arc2.value); if value -= then return(Â±); end; arcs := Coroplement_Ares(node I , node!]); node!]


0.196429217588

**207** : The function Complemenl_A re S also takes two nodes and gives a set of arcs whose features exist in the first node but not in the second.


0.213258102765

**209** : When unification of two nodes results in a node with an arc with a feature in ifeatures, it yields I because of feature inconsistency.


0.305319111609

**208** : An inhibited feature function is implemented using the gestures field of nodes.



##The Citing Sentences :
Copying of nodes will be delayed until a destructive change is about to take place.

###The Corpus Reference Sentences :
0.9927360209


**23** : Copying sharable parts is called redundant copying.

0.996668727908


**141** : 5 disables structure sharing, ttowever, this whole copying is not necessary if a lazy evaluation method is used.

0.221673852631


**142** : With such a method, it is possible to delay copying a node until either its own contents need to change (e.g., node G3/Ka c !7>) or until it is found to have an arc (sequence) to a node t, hat needs to be copied (e.g., node X G3/<a c> in Fig.


###Our Reference Sentences :
0.0739843836484

**187** : 2328, 1992 node structure 111=111111110M11= rinIMINI/a set o arc structures 11=121111111= IEZZEINIMINI=ED 011=1111111111=12=11M011â 1 MIIIIIIIIIMIEMIE 1/4=11â¢1111ELIMMTIM 111121MIMICIIMEDIEED Figure 4: Data Structures Function Unify(nodel , nodc2) begin node] := Dereference(nodel); riode2 :-= Dereference(ruxle2); if node] = node then return( node 1); nodel . forward := node2 ; node2.tsymbol := node] .tsurnbol AT node2.tsymbol; if node2.tsymbol = _I_ then return(i) node2.ileatures node] .ifeatures U node2 :ilea tures ; if node2.ifeaturesn { arc. feature I arc E node] .arcs U node .nrcs) 0 then returri(1.); node2.dnodes := node!


0.112555568934

**187** : 2328, 1992 node structure 111=111111110M11= rinIMINI/a set o arc structures 11=121111111= IEZZEINIMINI=ED 011=1111111111=12=11M011â 1 MIIIIIIIIIMIEMIE 1/4=11â¢1111ELIMMTIM 111121MIMICIIMEDIEED Figure 4: Data Structures Function Unify(nodel , nodc2) begin node] := Dereference(nodel); riode2 :-= Dereference(ruxle2); if node] = node then return( node 1); nodel . forward := node2 ; node2.tsymbol := node] .tsurnbol AT node2.tsymbol; if node2.tsymbol = _I_ then return(i) node2.ileatures node] .ifeatures U node2 :ilea tures ; if node2.ifeaturesn { arc. feature I arc E node] .arcs U node .nrcs) 0 then returri(1.); node2.dnodes := node!


0.169033628526

**202** : The function Unify takes two input nodes and puts them in a K.-class by letting one input be the forward field values.


0.174492254624

**208** : An inhibited feature function is implemented using the gestures field of nodes.


0.181968562171

**188** : .dnodes U node2.dnodes; if {nodel , node2} fl node2.dnodes tt then rettirn(..t.); arcpairs := Shared _Arc_Pairs(nodel , node2); for (arc] , arc2) in Â°repairs do begin value := Unify(orcl :value, arc2.value); if value -= then return(Â±); end; arcs := Coroplement_Ares(node I , node!]); node!]



##The Citing Sentences :
Kogure uses a revised copynode procedure which maintains copy dependency information in order to avoid immediate copying.

###The Corpus Reference Sentences :
0.968036414708


**23** : Copying sharable parts is called redundant copying.

0.985341450165


**141** : 5 disables structure sharing, ttowever, this whole copying is not necessary if a lazy evaluation method is used.

0.995554736385


**142** : With such a method, it is possible to delay copying a node until either its own contents need to change (e.g., node G3/Ka c !7>) or until it is found to have an arc (sequence) to a node t, hat needs to be copied (e.g., node X G3/<a c> in Fig.


###Our Reference Sentences :
0.0739843836484

**187** : 2328, 1992 node structure 111=111111110M11= rinIMINI/a set o arc structures 11=121111111= IEZZEINIMINI=ED 011=1111111111=12=11M011â 1 MIIIIIIIIIMIEMIE 1/4=11â¢1111ELIMMTIM 111121MIMICIIMEDIEED Figure 4: Data Structures Function Unify(nodel , nodc2) begin node] := Dereference(nodel); riode2 :-= Dereference(ruxle2); if node] = node then return( node 1); nodel . forward := node2 ; node2.tsymbol := node] .tsurnbol AT node2.tsymbol; if node2.tsymbol = _I_ then return(i) node2.ileatures node] .ifeatures U node2 :ilea tures ; if node2.ifeaturesn { arc. feature I arc E node] .arcs U node .nrcs) 0 then returri(1.); node2.dnodes := node!


0.112555568934

**187** : 2328, 1992 node structure 111=111111110M11= rinIMINI/a set o arc structures 11=121111111= IEZZEINIMINI=ED 011=1111111111=12=11M011â 1 MIIIIIIIIIMIEMIE 1/4=11â¢1111ELIMMTIM 111121MIMICIIMEDIEED Figure 4: Data Structures Function Unify(nodel , nodc2) begin node] := Dereference(nodel); riode2 :-= Dereference(ruxle2); if node] = node then return( node 1); nodel . forward := node2 ; node2.tsymbol := node] .tsurnbol AT node2.tsymbol; if node2.tsymbol = _I_ then return(i) node2.ileatures node] .ifeatures U node2 :ilea tures ; if node2.ifeaturesn { arc. feature I arc E node] .arcs U node .nrcs) 0 then returri(1.); node2.dnodes := node!


0.169033628526

**202** : The function Unify takes two input nodes and puts them in a K.-class by letting one input be the forward field values.


0.174492254624

**208** : An inhibited feature function is implemented using the gestures field of nodes.


0.181968562171

**188** : .dnodes U node2.dnodes; if {nodel , node2} fl node2.dnodes tt then rettirn(..t.); arcpairs := Shared _Arc_Pairs(nodel , node2); for (arc] , arc2) in Â°repairs do begin value := Unify(orcl :value, arc2.value); if value -= then return(Â±); end; arcs := Coroplement_Ares(node I , node!]); node!]



#analysing the annotation 17
**Not valid annotation**