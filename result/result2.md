##Total Features Number using contrast: 198

### mainpulating the section : 0

1 - **consists**: ,Contrast  ,Feature

2 - **treating**: ,Contrast

3 - **negative**: ,Contrast  ,Feature  ,Title

4 - **types**: ,Contrast  ,Feature

5 - **feature**: ,Contrast  ,Feature  ,Abstract

6 - **correspond**: ,Contrast  ,Feature

7 - **interpretation**: ,Contrast  ,Feature

8 - **negations**: ,Contrast  ,Feature  ,Abstract

9 - **framework**: ,Contrast  ,Feature

10 - **classified**: ,Contrast  ,Feature

11 - **descriptions**: ,Contrast  ,Feature  ,Abstract

12 - **definition**: ,Contrast

13 - **counterparts**: ,Contrast

14 - **pairs**: ,Contrast

15 - **classes**: ,Contrast  ,Feature

16 - **based**: ,Contrast  ,Feature

17 - **feature-structure**: ,Contrast

18 - **conjunction**: ,Contrast

19 - **feature-value**: ,Contrast  ,Feature

20 - **Disjunctive**: ,Contrast  ,Feature

21 - **interface**: ,Contrast

22 - **simple**: ,Contrast  ,Feature

23 - **corresponds**: ,Contrast

24 - **basis**: ,Contrast

25 - **treat**: ,Contrast  ,Feature

26 - **formalizations**: ,Contrast  ,Feature

27 - **tions**: ,Contrast  ,Feature

28 - **complex**: ,Contrast  ,Feature

29 - **extended**: ,Contrast  ,Feature

30 - **lattice**: ,Contrast  ,Feature  ,Abstract

31 - **objects**: ,Contrast  ,Feature

32 - **extensions**: ,Contrast  ,Feature

33 - **type-as-set**: ,Contrast

34 - **describe**: ,Contrast  ,Feature

35 - **feature-address**: ,Contrast  ,Feature

### mainpulating the section : 1

1 - **compact**: ,Contrast  ,Feature

2 - **lists**: ,Contrast  ,Feature

3 - **dis**: ,Contrast

4 - **represented**: ,Contrast

5 - **natural**: ,Contrast

6 - **fea**: ,Contrast

7 - **negative**: ,Contrast  ,Feature  ,Title

8 - **information**: ,Contrast

9 - **sim**: ,Contrast

10 - **typed**: ,Contrast

11 - **front**: ,Contrast

12 - **means**: ,Contrast

13 - **fist**: ,Contrast

14 - **descriptions**: ,Contrast  ,Feature  ,Abstract

15 - **language**: ,Contrast

16 - **ture**: ,Contrast

17 - **numbers**: ,Contrast  ,Feature

18 - **tion**: ,Contrast

19 - **takes**: ,Contrast  ,Feature

20 - **Disjunctive**: ,Contrast  ,Feature

21 - **results**: ,Contrast

22 - **complement**: ,Contrast  ,Feature

23 - **linguistic**: ,Contrast  ,Feature

24 - **confidence=**: ,Contrast  ,Feature

25 - **understand**: ,Contrast  ,Feature

26 - **values**: ,Contrast  ,Feature

27 - **make**: ,Contrast  ,Feature

28 - **complex**: ,Contrast  ,Feature

29 - **finite**: ,Contrast  ,Feature

30 - **easy**: ,Contrast

31 - **agreement**: ,Contrast  ,Feature  ,Abstract

32 - **specifies**: ,Contrast

33 - **describe**: ,Contrast  ,Feature

34 - **grammatical**: ,Contrast  ,Feature

35 - **allowing**: ,Contrast

36 - **disjunctions**: ,Contrast

### mainpulating the section : 2

1 - **equivalence**: ,Contrast

2 - **denoted**: ,Contrast  ,Feature

3 - **address**: ,Contrast  ,Feature

4 - **represented**: ,Contrast

5 - **types**: ,Contrast  ,Feature

6 - **tag**: ,Contrast  ,Feature

7 - **feature**: ,Contrast  ,Feature  ,Abstract

8 - **orders**: ,Contrast  ,Feature

9 - **term**: ,Contrast  ,Feature  ,Abstract

10 - **subset**: ,Contrast

11 - **domains**: ,Contrast  ,Feature

12 - **denotes**: ,Contrast  ,Feature

13 - **occurs**: ,Contrast

14 - **dlist**: ,Contrast  ,Feature

15 - **relation**: ,Contrast  ,Feature

16 - **directed**: ,Contrast

17 - **sets**: ,Contrast  ,Feature

18 - **written**: ,Contrast

19 - **apos**: ,Contrast  ,Feature  ,Abstract

20 - **empty**: ,Contrast

21 - **assigning**: ,Contrast

22 - **finite**: ,Contrast  ,Feature

23 - **disagreements**: ,Contrast  ,Feature

24 - **greatest**: ,Contrast

25 - **function**: ,Contrast  ,Feature

26 - **called**: ,Contrast  ,Feature

27 - **defined**: ,Contrast  ,Feature

28 - **exist**: ,Contrast

29 - **constructed**: ,Contrast

30 - **symbol**: ,Contrast  ,Feature  ,Abstract

31 - **structures**: ,Contrast  ,Feature  ,Abstract

32 - **inhibited**: ,Contrast

33 - **augmented**: ,Contrast  ,Feature

### mainpulating the section : 3

1 - **AuG**: ,Contrast

2 - **subsumption**: ,Contrast  ,Feature

3 - **graph**: ,Contrast  ,Feature

4 - **upper**: ,Contrast

5 - **implemented**: ,Contrast  ,Feature

6 - **consisting**: ,Contrast

7 - **bol**: ,Contrast

8 - **put**: ,Contrast

9 - **types**: ,Contrast  ,Feature

10 - **join**: ,Contrast  ,Feature

11 - **meet**: ,Contrast  ,Feature

12 - **mented**: ,Contrast

13 - **quot**: ,Contrast  ,Feature

14 - **elements**: ,Contrast  ,Feature

15 - **orders**: ,Contrast  ,Feature

16 - **maximal**: ,Contrast

17 - **operation**: ,Contrast  ,Feature

18 - **methods**: ,Contrast  ,Feature

19 - **definition**: ,Contrast

20 - **counterparts**: ,Contrast

21 - **manner**: ,Contrast

22 - **takes**: ,Contrast  ,Feature

23 - **pairs**: ,Contrast

24 - **inconsistency**: ,Contrast  ,Feature

25 - **sets**: ,Contrast  ,Feature

26 - **arc**: ,Contrast  ,Feature

27 - **apos**: ,Contrast  ,Feature  ,Abstract

28 - **complement**: ,Contrast  ,Feature

29 - **i.e.**: ,Contrast

30 - **define**: ,Contrast

31 - **func**: ,Contrast

32 - **thesame**: ,Contrast

33 - **sym**: ,Contrast

34 - **lower**: ,Contrast

35 - **lattice**: ,Contrast  ,Feature  ,Abstract

36 - **unification**: ,Contrast  ,Feature  ,Abstract

37 - **amp**: ,Contrast  ,Feature

### mainpulating the section : 4

1 - **logic-based**: ,Contrast  ,Feature

2 - **compact**: ,Contrast  ,Feature

3 - **include**: ,Contrast  ,Feature

4 - **neg**: ,Contrast  ,Feature

5 - **negative**: ,Contrast  ,Feature  ,Title

6 - **descrip**: ,Contrast  ,Feature

7 - **compactly**: ,Contrast  ,Feature

8 - **information**: ,Contrast  ,Feature

9 - **subcat**: ,Contrast  ,Feature

10 - **typed**: ,Contrast  ,Feature

11 - **developed**: ,Contrast  ,Feature

12 - **negations**: ,Contrast  ,Feature  ,Abstract

13 - **paper**: ,Contrast  ,Feature  ,Abstract

14 - **existences**: ,Contrast  ,Feature  ,Abstract

15 - **easier**: ,Contrast  ,Feature

16 - **scriptions**: ,Contrast  ,Feature

17 - **descriptions**: ,Contrast  ,Feature  ,Abstract

18 - **methods**: ,Contrast  ,Feature

19 - **formation**: ,Contrast  ,Feature

20 - **representing**: ,Contrast  ,Feature

21 - **kinds**: ,Contrast  ,Feature

22 - **tion**: ,Contrast  ,Feature

23 - **treated**: ,Contrast  ,Feature

24 - **debugging**: ,Contrast  ,Feature

25 - **generalization**: ,Contrast  ,Feature

26 - **efficient**: ,Contrast  ,Feature

27 - **extending**: ,Contrast  ,Feature

28 - **ative**: ,Contrast  ,Feature

29 - **tures**: ,Contrast  ,Feature

30 - **relation**: ,Contrast  ,Feature

31 - **based**: ,Contrast  ,Feature

32 - **struc**: ,Contrast  ,Feature

33 - **complement**: ,Contrast  ,Feature

34 - **treat**: ,Contrast  ,Feature

35 - **linguistic**: ,Contrast  ,Feature

36 - **formalizations**: ,Contrast  ,Feature

37 - **values**: ,Contrast  ,Feature

38 - **promising**: ,Contrast  ,Feature

39 - **formalism**: ,Contrast  ,Feature

40 - **make**: ,Contrast  ,Feature

41 - **gorithms**: ,Contrast  ,Feature

42 - **obtain**: ,Contrast  ,Feature

43 - **easy**: ,Contrast  ,Feature

44 - **unification-based**: ,Contrast  ,Feature

45 - **introduces**: ,Contrast  ,Feature

46 - **primitive**: ,Contrast  ,Feature

47 - **describe**: ,Contrast  ,Feature

48 - **feature-address**: ,Contrast  ,Feature

49 - **structures**: ,Contrast  ,Feature  ,Abstract

50 - **algorithm**: ,Contrast  ,Feature  ,Abstract

51 - **augmented**: ,Contrast  ,Feature

### mainpulating the section : 5

##Total Features Number : 140

### mainpulating the section : 0

1 - **consists** ,Feature

2 - **negative** ,Feature  ,Title

3 - **types** ,Feature

4 - **feature** ,Feature  ,Abstract

5 - **correspond** ,Feature

6 - **interpretation** ,Feature

7 - **negations** ,Feature  ,Abstract

8 - **framework** ,Feature

9 - **classified** ,Feature

10 - **descriptions** ,Feature  ,Abstract

11 - **classes** ,Feature

12 - **based** ,Feature

13 - **feature-value** ,Feature

14 - **Disjunctive** ,Feature

15 - **simple** ,Feature

16 - **treat** ,Feature

17 - **formalizations** ,Feature

18 - **tions** ,Feature

19 - **complex** ,Feature

20 - **extended** ,Feature

21 - **lattice** ,Feature  ,Abstract

22 - **objects** ,Feature

23 - **extensions** ,Feature

24 - **describe** ,Feature

25 - **feature-address** ,Feature

### mainpulating the section : 1

1 - **compact** ,Feature

2 - **lists** ,Feature

3 - **negative**: ,Contrast  ,Feature  ,Title

4 - **descriptions**: ,Contrast  ,Feature  ,Abstract

5 - **numbers** ,Feature

6 - **takes** ,Feature

7 - **complement** ,Feature

8 - **linguistic** ,Feature

9 - **confidence=** ,Feature

10 - **understand** ,Feature

11 - **values** ,Feature

12 - **make** ,Feature

13 - **complex**: ,Contrast  ,Feature

14 - **finite** ,Feature

15 - **agreement** ,Feature  ,Abstract

16 - **describe**: ,Contrast  ,Feature

17 - **grammatical** ,Feature

### mainpulating the section : 2

1 - **denoted** ,Feature

2 - **address** ,Feature

3 - **types**: ,Contrast  ,Feature

4 - **tag** ,Feature

5 - **feature**: ,Contrast  ,Feature  ,Abstract

6 - **orders** ,Feature

7 - **term** ,Feature  ,Abstract

8 - **domains** ,Feature

9 - **denotes** ,Feature

10 - **dlist** ,Feature

11 - **relation** ,Feature

12 - **sets** ,Feature

13 - **apos** ,Feature  ,Abstract

14 - **finite**: ,Contrast  ,Feature

15 - **disagreements** ,Feature

16 - **function** ,Feature

17 - **called** ,Feature

18 - **defined** ,Feature

19 - **symbol** ,Feature  ,Abstract

20 - **structures** ,Feature  ,Abstract

21 - **augmented** ,Feature

### mainpulating the section : 3

1 - **subsumption** ,Feature

2 - **graph** ,Feature

3 - **implemented** ,Feature

4 - **types**: ,Contrast  ,Feature

5 - **join** ,Feature

6 - **meet** ,Feature

7 - **quot** ,Feature

8 - **elements** ,Feature

9 - **orders**: ,Contrast  ,Feature

10 - **operation** ,Feature

11 - **methods** ,Feature

12 - **takes**: ,Contrast  ,Feature

13 - **inconsistency** ,Feature

14 - **sets**: ,Contrast  ,Feature

15 - **arc** ,Feature

16 - **apos**: ,Contrast  ,Feature  ,Abstract

17 - **complement**: ,Contrast  ,Feature

18 - **lattice**: ,Contrast  ,Feature  ,Abstract

19 - **unification** ,Feature  ,Abstract

20 - **amp** ,Feature

### mainpulating the section : 4

1 - **logic-based** ,Feature

2 - **compact**: ,Contrast  ,Feature

3 - **include** ,Feature

4 - **neg** ,Feature

5 - **negative**: ,Contrast  ,Feature  ,Title

6 - **descrip** ,Feature

7 - **compactly** ,Feature

8 - **information**: ,Contrast  ,Feature

9 - **subcat** ,Feature

10 - **typed**: ,Contrast  ,Feature

11 - **developed** ,Feature

12 - **negations**: ,Contrast  ,Feature  ,Abstract

13 - **paper** ,Feature  ,Abstract

14 - **existences** ,Feature  ,Abstract

15 - **easier** ,Feature

16 - **scriptions** ,Feature

17 - **descriptions**: ,Contrast  ,Feature  ,Abstract

18 - **methods**: ,Contrast  ,Feature

19 - **formation** ,Feature

20 - **representing** ,Feature

21 - **kinds** ,Feature

22 - **tion**: ,Contrast  ,Feature

23 - **treated** ,Feature

24 - **debugging** ,Feature

25 - **generalization** ,Feature

26 - **efficient** ,Feature

27 - **extending** ,Feature

28 - **ative** ,Feature

29 - **tures** ,Feature

30 - **relation**: ,Contrast  ,Feature

31 - **based**: ,Contrast  ,Feature

32 - **struc** ,Feature

33 - **complement**: ,Contrast  ,Feature

34 - **treat**: ,Contrast  ,Feature

35 - **linguistic**: ,Contrast  ,Feature

36 - **formalizations**: ,Contrast  ,Feature

37 - **values**: ,Contrast  ,Feature

38 - **promising** ,Feature

39 - **formalism** ,Feature

40 - **make**: ,Contrast  ,Feature

41 - **gorithms** ,Feature

42 - **obtain** ,Feature

43 - **easy**: ,Contrast  ,Feature

44 - **unification-based** ,Feature

45 - **introduces** ,Feature

46 - **primitive** ,Feature

47 - **describe**: ,Contrast  ,Feature

48 - **feature-address**: ,Contrast  ,Feature

49 - **structures**: ,Contrast  ,Feature  ,Abstract

50 - **algorithm** ,Feature  ,Abstract

51 - **augmented**: ,Contrast  ,Feature

### mainpulating the section : 5

#The Summary
**ze take 5 percent of the important and long sentences for making the summary**

In this paper, both these type structures and the type symbol lattice on which term structures are definedare extended to treat negative descriptions.

Nega tions of type symbols are treated by extending type symbol lattices, and negations of feature existwicesand feature-address disagreements are treated by ex tending term structures.

</sectionHeader> <subsectionHeader confidence="0.434954"> Descriptions of TFSs </subsectionHeader> <bodyText confidence="0.971192533333333">In describing linguistic information using (typed) feature structures, negative descriptions make the description compact, intuitive, and hence easy to understand.

Definition 4 A term is a triple (Ar, v) where A is a term domain on .F, r is a type symbol function from .7 to T such that r(T* â A) = IT), and v is a tag symbol function from A to V. Given a tag symbol function v, Addl.., denotes the function from a tag symbol to the set of addresses: Addr,(X) := Al v(p) = X}.

The set 14./Y7&apos; of well-formed terms includes many terms that have the same type symbol function, the same coreference relations, the same inhibited featurefunction, and the same disagreement address func tion but different tag symbol functions.

a AT b = c if and only if lain 114 = A feature symbol denotes a function from a subset of U to U. A feature path is a finite string of feature symbols and denotes the function obtained by the composition of the functions that the feature symbols denote.

A subdomain of a term domain, corresponding to a subgraph, is defined as follows, Definition 3 Given a term domain A and a feature address p E A, the subdomain of A at p is defined to be the term domain A/p := {P&apos; I P â¢ P&apos; E A}.

AltKaci&apos;s term structure, the basis of the tit-type, is defined by assigning a type symbol and a tag symbol to each feature address as follows.

2328, 1992 node structure 111=111111110M11= rinIMINI/a set o arc structures 11=121111111= IEZZEINIMINI=ED 011=1111111111=12=11M011â 1 MIIIIIIIIIMIEMIE 1/4=11â¢1111ELIMMTIM 111121MIMICIIMEDIEED Figure 4: Data Structures Function Unify(nodel , nodc2) begin node] := Dereference(nodel); riode2 :-= Dereference(ruxle2); if node] = node then return( node 1); nodel . forward := node2 ; node2.tsymbol := node] .tsurnbol AT node2.tsymbol; if node2.tsymbol = _I_ then return(i) node2.ileatures node] .ifeatures U node2 :ilea tures ; if node2.ifeaturesn { arc. feature I arc E node] .arcs U node .nrcs) 0 then returri(1.); node2.dnodes := node!

The function Shared_Arc_Pairs takes two nodes as its inputs and gives a set of arc pairs each consisting of both inputs&apos; arcs widi a shared feature.

In this paper, FSs have been augmented, using a promising method of for AltKaci&apos;s type, to allow three kinds of negative descriptions of them to be treated.In a formalization of typed feature structures, neg ative descriptions can be decomposed into three kinds of negations: negations of type symbols, negations of feature existences, and negations of feature-address value agreements.


/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/scipy/spatial/distance.py:287: RuntimeWarning: invalid value encountered in double_scalars
  dist = 1.0 - np.dot(u, v) / (norm(u) * norm(v))
/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/scipy/spatial/distance.py:287: RuntimeWarning: invalid value encountered in true_divide
  dist = 1.0 - np.dot(u, v) / (norm(u) * norm(v))

#analysing the annotation 1

##The Citing Sentences :
While an improvement over simple destructive unification, Tomabechi's approach still suffers from what Kogure (Kogure, 1990) calls redundant copying.

###The Corpus Reference Sentences :
1.0


**21** : itowever, the problem with his method is that a unitication result graph consists only of newly created structures.

1.0


**22** : This is unnecessary because there are often input snbgraphs that can be used as part of the result graph without any modification, or as sharable parts between one of the input graphs and the result graph.

0.987573324609


**23** : Copying sharable parts is called redundant copying.


###Our Reference Sentences :
0.228885046625

**194** : Unification The unification operation for augmented tk-terms or augmented TFSs has been implemented using graphunification techniques.


0.276490154695

**213** : To simplify the explanation, the destructive version of graph unification is used above.


0.317442840543

**214** : Other versions based on more efficient graph unification methods such as Wroblewski's and Kogure's method [23, 16) have also been developed.


0.334102156723

**215** : Furthermore, it is easy to modify other graph unification inethods[21, 61 to allow augmented 1TSs.


0.370854377131

**196** : The unification oper ation for such DGs corresponds to a graph merging operation.



#analysing the annotation 2

##The Citing Sentences :
The extension is classified into class (1) above.Based on this paper's formalization, unification algorithms have been developed using graph unification techniques[23, 16].

###The Corpus Reference Sentences :
0.336158231133


**0** : Strategic Lazy Incremental Copy Graph Unification


###Our Reference Sentences :
0.23425222415

**44** : The extension is classified into class (1) above.Based on this paper's formalization, unification al gorithms have been developed using graph unificationtechniques[23, 16].


0.417710203026

**198** : In a destructive graph unification method, winch is very simple, such a graph is represented by the data structures in Figure 4.


0.443182559139

**213** : To simplify the explanation, the destructive version of graph unification is used above.


0.459386231146

**214** : Other versions based on more efficient graph unification methods such as Wroblewski's and Kogure's method [23, 16) have also been developed.


0.472581105131

**215** : Furthermore, it is easy to modify other graph unification inethods[21, 61 to allow augmented 1TSs.



#analysing the annotation 3

##The Citing Sentences :
Other versions based on more efficient graph unification methods such as Wroblewski's and Kogure's method [23, 16] have also been developed.

###The Corpus Reference Sentences :
0.176732482686


**0** : Strategic Lazy Incremental Copy Graph Unification


###Our Reference Sentences :
0.115516469996

**214** : Other versions based on more efficient graph unification methods such as Wroblewski's and Kogure's method [23, 16) have also been developed.


0.178428534227

**198** : In a destructive graph unification method, winch is very simple, such a graph is represented by the data structures in Figure 4.


0.180288380523

**213** : To simplify the explanation, the destructive version of graph unification is used above.


0.237788067954

**215** : Furthermore, it is easy to modify other graph unification inethods[21, 61 to allow augmented 1TSs.


0.279856053617

**196** : The unification oper ation for such DGs corresponds to a graph merging operation.



#analysing the annotation 4

##The Citing Sentences :
This is inefficient with many copy operations due to unfications of unnecessary features that do not contribute to successful unification [6].

###The Corpus Reference Sentences :
0.740040204118


**205** : Furthermore, structure sharing increases the portion of token identical substructures of FSs which makes it efficient to keep unification results of substructures of FSs and reuse them.

1.0


**206** : This reduces repeated calculation of substructures.


###Our Reference Sentences :
0.19182021021

**76** : OF COLING92, NANTES, AUG. 2328, 1992 3.1 Typed Feature Structures as.


0.21177063986

**146** : Such an inconsistency is called a feature inconsistency.


0.242305059873

**22** : In order to treat feature domains of complex FSsand to treat taxonomic hierarchies of symbolic feature values, type (or sort) hierarchies have been in troduced, allowing definition of typed (or sorted) feature-structures (Ms).


0.24871074421

**156** : This is also true for feature incon sistency and tag inconsistency.


0.290521932126

**73** : &apos;Fenn structures are first augmented with structures representing in features and disagreement of feature address values.



##The Citing Sentences :
Thus treatments such as strategic unification [6] have been developed.

###The Corpus Reference Sentences :
0.50054290505


**205** : Furthermore, structure sharing increases the portion of token identical substructures of FSs which makes it efficient to keep unification results of substructures of FSs and reuse them.

1.0


**206** : This reduces repeated calculation of substructures.


###Our Reference Sentences :
0.19182021021

**76** : OF COLING92, NANTES, AUG. 2328, 1992 3.1 Typed Feature Structures as.


0.21177063986

**146** : Such an inconsistency is called a feature inconsistency.


0.242305059873

**22** : In order to treat feature domains of complex FSsand to treat taxonomic hierarchies of symbolic feature values, type (or sort) hierarchies have been in troduced, allowing definition of typed (or sorted) feature-structures (Ms).


0.24871074421

**156** : This is also true for feature incon sistency and tag inconsistency.


0.266151816031

**194** : Unification The unification operation for augmented tk-terms or augmented TFSs has been implemented using graphunification techniques.



#analysing the annotation 5

##The Citing Sentences :
This observation is the basis for a reordering method proposed by Kogure [1990].

###The Corpus Reference Sentences :
1.0


**3** : The other, called ti~e strategic incremental copy graph unification method, uses an early failure finding strategy which first tries to unify ;ubstructures tending to fail in unification; this method is; based on stochastic data on tim likelihood of failure and ,'educes unnecessary computation.


###Our Reference Sentences :
0.779316200239

**221** : It is also shown that the first kind can be treated by extending type symbol lattices to include complement type symbols.&apos;Die proposed formalization can provide efficient al AcrEs 05 COLING92, NANTES, 2328 Â°art 1992 3 8 5 PROC.


0.799522908798

**216** : This paper has proposed an augmentation of feature structures (FSs) which introduces negative in formation into FSs in unification-based formalisms.Unification-based linguistic formalisms use lbs to describe linguistic objects and phenomena.


0.989161098083

**19** : Moshier and Rounds[171 propose a formal framework which treats negative feature descriptions on the basis of intuitionistic logic.


0.998045844514

**99** : AltKaci&apos;s term structure, the basis of the tit-type, is defined by assigning a type symbol and a tag symbol to each feature address as follows.


1.0

**217** : Because lin guistic information can be described compactly usingdisjunctive and negative descriptions, l&apos;Ss and feature descriptions are required to treat such descrip tions.



#analysing the annotation 6

##The Citing Sentences :
Thus for any automatic counting scheme some constant shuffling and reshuffling of the conjunct order needs to be applied until the order stabilizes (see also [Kogure 1990]).

###The Corpus Reference Sentences :
nan


**186** : in this method, theretbre, the failure tendency information is acquired by a learning process.

nan


**187** : That is, the SING unification method applied in an analysis system uses the failure tendency information acquired by a learning analysis process.

nan


**188** : in the learning process, when FS unification is applied, feature treatment orders are randomized for the sake of random extraction.


###Our Reference Sentences :
1.0

**216** : This paper has proposed an augmentation of feature structures (FSs) which introduces negative in formation into FSs in unification-based formalisms.Unification-based linguistic formalisms use lbs to describe linguistic objects and phenomena.


1.0

**217** : Because lin guistic information can be described compactly usingdisjunctive and negative descriptions, l&apos;Ss and feature descriptions are required to treat such descrip tions.


1.0

**214** : Other versions based on more efficient graph unification methods such as Wroblewski's and Kogure's method [23, 16) have also been developed.


1.0

**215** : Furthermore, it is easy to modify other graph unification inethods[21, 61 to allow augmented 1TSs.


1.0

**212** : These computations require negligible additional computation.



#analysing the annotation 7

##The Citing Sentences :
The lazy copying approach ([Kogure, 1990], and [Emele, 1991] for lazy copying in TFS with historical backtracking) copies only overlapping parts of the structure.

###The Corpus Reference Sentences :
0.581361247404


**39** : This paper proposes an FS unification method that allows structure sharing with constant m'der node access time.

0.34444985659


**40** : This method achieves structure sharing by introducing lazy copying to Wroblewski's incremental copy graph unification method.

1.0


**78** : Then, the unification of tl anti t2 is defined as their greatest lower bound or the meet.


###Our Reference Sentences :
0.30643640093

**28** : Asubsumption relation is defined on these term structures.


0.577044911908

**224** : Logic-based frameworks can be used to obtain the data structures for this paper&apos;s formalization.Unification algorithms for augmented terms or augmented TFSs have been developed using graph uni fication techniques.


0.57935753464

**216** : This paper has proposed an augmentation of feature structures (FSs) which introduces negative in formation into FSs in unification-based formalisms.Unification-based linguistic formalisms use lbs to describe linguistic objects and phenomena.


0.592460666723

**195** : A term structure is repre sented as a directed graph by assigning a graph nodeto each K-class as in Figure 2.


0.61615754367

**219** : It is shown that the second andthird kinds can be treated by augmenting term struc tures to include structures representing such kinds of descriptions.



#analysing the annotation 8

##The Citing Sentences :
At least two schemes have been proposed recently ])a.~ed Ul)OU this observation (namely [Kogure.

###The Corpus Reference Sentences :
1.0


**0** : Strategic Lazy Incremental Copy Graph Unification


###Our Reference Sentences :
0.774158734623

**221** : It is also shown that the first kind can be treated by extending type symbol lattices to include complement type symbols.&apos;Die proposed formalization can provide efficient al AcrEs 05 COLING92, NANTES, 2328 Â°art 1992 3 8 5 PROC.


0.794837681764

**216** : This paper has proposed an augmentation of feature structures (FSs) which introduces negative in formation into FSs in unification-based formalisms.Unification-based linguistic formalisms use lbs to describe linguistic objects and phenomena.


1.0

**217** : Because lin guistic information can be described compactly usingdisjunctive and negative descriptions, l&apos;Ss and feature descriptions are required to treat such descrip tions.


1.0

**214** : Other versions based on more efficient graph unification methods such as Wroblewski's and Kogure's method [23, 16) have also been developed.


1.0

**215** : Furthermore, it is easy to modify other graph unification inethods[21, 61 to allow augmented 1TSs.



##The Citing Sentences :
1990] and [Emele, 1991]); however, both schemes are I)ased upon the increlllent'al Col)yiug sehellle all(l ~-LS ([e- scribed in [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi'om Early Copying as defined in that article.

###The Corpus Reference Sentences :
1.0


**0** : Strategic Lazy Incremental Copy Graph Unification


###Our Reference Sentences :
0.0932721719024

**79** : A signature is formally defined as follows, Definition 1 A signature is a quadruple (7, &lt;7 V) consisting of: 1.


0.143218790908

**162** : The subsumption orders on W.TT and on sP are defined as follows.


0.280281439351

**142** : To treat, such inconsistency, a relation 41 on 311.1.TY is defined as follows.


0.301758978806

**149** : lien cc, the three kinds of inconsistency are treatedintegratedly by a relation ff on W.FT defined as fol lows.


0.317489110086

**158** : Thus, we can defined the augmented 0-types as follows.



#analysing the annotation 9
**Not valid annotation**

#analysing the annotation 10

##The Citing Sentences :
2In the large-scale HPSG-based spoken Japanese analysis system developed at ATR, sometimes 98 percent of the elapsed time is devoted to graph unification ([Kogure, 1990]).

###The Corpus Reference Sentences :
0.552135855434


**205** : Furthermore, structure sharing increases the portion of token identical substructures of FSs which makes it efficient to keep unification results of substructures of FSs and reuse them.


###Our Reference Sentences :
0.0964218950322

**213** : To simplify the explanation, the destructive version of graph unification is used above.


0.122716479524

**214** : Other versions based on more efficient graph unification methods such as Wroblewski's and Kogure's method [23, 16) have also been developed.


0.126746961611

**198** : In a destructive graph unification method, winch is very simple, such a graph is represented by the data structures in Figure 4.


0.144128522961

**215** : Furthermore, it is easy to modify other graph unification inethods[21, 61 to allow augmented 1TSs.


0.191365764353

**196** : The unification oper ation for such DGs corresponds to a graph merging operation.



#analysing the annotation 11

##The Citing Sentences :
That is, unless some new scheme for reducing excessive copying is introduced such as scucture-sharing of an unchanged shared-forest ([Kogure, 1990]).

###The Corpus Reference Sentences :
nan


**11** : For example, a spoken Present.

1.0


**14** : Japanese analysis system based on llPSG[Kogure 891 uses 90% - 98% of the elapsed time in FS unification.


###Our Reference Sentences :
0.961818772155

**201** : By traversing two DGs&apos; nodeswith the same feature-address simultaneously, calcu lating the union of their K-classes, and copying arcs, their unification can be calculated as in Figure 5.


1.0

**216** : This paper has proposed an augmentation of feature structures (FSs) which introduces negative in formation into FSs in unification-based formalisms.Unification-based linguistic formalisms use lbs to describe linguistic objects and phenomena.


1.0

**217** : Because lin guistic information can be described compactly usingdisjunctive and negative descriptions, l&apos;Ss and feature descriptions are required to treat such descrip tions.


1.0

**214** : Other versions based on more efficient graph unification methods such as Wroblewski's and Kogure's method [23, 16) have also been developed.


1.0

**215** : Furthermore, it is easy to modify other graph unification inethods[21, 61 to allow augmented 1TSs.



#analysing the annotation 12

##The Citing Sentences :
A more eNcient unification algorithm would avoid this redundant copying (copying structures that can be shared by the input and resultant graphs) (Kogure, 1990).

###The Corpus Reference Sentences :
0.236774611875


**203** : The LING unification method achieves structure sharing without the O(log d) data access overhead of Pereira's method.

0.572655157786


**22** : This is unnecessary because there are often input snbgraphs that can be used as part of the result graph without any modification, or as sharable parts between one of the input graphs and the result graph.

0.985837307959


**23** : Copying sharable parts is called redundant copying.

0.937204813599


**24** : A better method would nfinimize the copying of sharable varts.


###Our Reference Sentences :
0.185828668971

**198** : In a destructive graph unification method, winch is very simple, such a graph is represented by the data structures in Figure 4.


0.327294198289

**195** : A term structure is repre sented as a directed graph by assigning a graph nodeto each K-class as in Figure 2.


0.365926009169

**213** : To simplify the explanation, the destructive version of graph unification is used above.


0.38437788625

**214** : Other versions based on more efficient graph unification methods such as Wroblewski's and Kogure's method [23, 16) have also been developed.


0.399403504688

**215** : Furthermore, it is easy to modify other graph unification inethods[21, 61 to allow augmented 1TSs.



#analysing the annotation 13

##The Citing Sentences :
Kogure (1990) proposed a lazy incremental copy graph (LING) unification that uses dependency-directed eol)yiug

###The Corpus Reference Sentences :
0.533978825622


**22** : This is unnecessary because there are often input snbgraphs that can be used as part of the result graph without any modification, or as sharable parts between one of the input graphs and the result graph.

1.0


**23** : Copying sharable parts is called redundant copying.

1.0


**24** : A better method would nfinimize the copying of sharable varts.


###Our Reference Sentences :
0.0982165531767

**213** : To simplify the explanation, the destructive version of graph unification is used above.


0.1244589122

**214** : Other versions based on more efficient graph unification methods such as Wroblewski's and Kogure's method [23, 16) have also been developed.


0.128074266106

**198** : In a destructive graph unification method, winch is very simple, such a graph is represented by the data structures in Figure 4.


0.145828427716

**215** : Furthermore, it is easy to modify other graph unification inethods[21, 61 to allow augmented 1TSs.


0.192971847998

**196** : The unification oper ation for such DGs corresponds to a graph merging operation.



#analysing the annotation 14

##The Citing Sentences :
A better method would avoid (eliminate) such redundant copying as it is called by [Kogure 90].

###The Corpus Reference Sentences :
-2.22044604925e-16


**23** : Copying sharable parts is called redundant copying.

0.838453052196


**24** : A better method would nfinimize the copying of sharable varts.


###Our Reference Sentences :
0.285889938667

**117** : here, a is an equivalence relation and a a class is called a coreference class.


0.600938127418

**148** : Such an inconsistency is called a tag inconsistency.


0.615103611639

**141** : Such an inconsistency is called a type inconsis tency.


0.761820464428

**146** : Such an inconsistency is called a feature inconsistency.


0.85239410159

**70** : Such it term iscalled an augmented thterm and a type with an aug mented 0-term as its syntax is called an augmented0-type.



#analysing the annotation 15

##The Citing Sentences :
Similarly, in Kogure's approach, not all redundant copying is avoided in cases where there exists a feature path (a sequence of nodes connected by arcs) to a node that needs to be copied.

###The Corpus Reference Sentences :
0.996138498122


**23** : Copying sharable parts is called redundant copying.

0.998119795275


**141** : 5 disables structure sharing, ttowever, this whole copying is not necessary if a lazy evaluation method is used.

0.208979077533


**142** : With such a method, it is possible to delay copying a node until either its own contents need to change (e.g., node G3/Ka c !7>) or until it is found to have an arc (sequence) to a node t, hat needs to be copied (e.g., node X G3/<a c> in Fig.


###Our Reference Sentences :
0.0727466359086

**187** : 2328, 1992 node structure 111=111111110M11= rinIMINI/a set o arc structures 11=121111111= IEZZEINIMINI=ED 011=1111111111=12=11M011â 1 MIIIIIIIIIMIEMIE 1/4=11â¢1111ELIMMTIM 111121MIMICIIMEDIEED Figure 4: Data Structures Function Unify(nodel , nodc2) begin node] := Dereference(nodel); riode2 :-= Dereference(ruxle2); if node] = node then return( node 1); nodel . forward := node2 ; node2.tsymbol := node] .tsurnbol AT node2.tsymbol; if node2.tsymbol = _I_ then return(i) node2.ileatures node] .ifeatures U node2 :ilea tures ; if node2.ifeaturesn { arc. feature I arc E node] .arcs U node .nrcs) 0 then returri(1.); node2.dnodes := node!


0.16846013606

**207** : The function Complemenl_A re S also takes two nodes and gives a set of arcs whose features exist in the first node but not in the second.


0.184935524158

**188** : .dnodes U node2.dnodes; if {nodel , node2} fl node2.dnodes tt then rettirn(..t.); arcpairs := Shared _Arc_Pairs(nodel , node2); for (arc] , arc2) in Â°repairs do begin value := Unify(orcl :value, arc2.value); if value -= then return(Â±); end; arcs := Coroplement_Ares(node I , node!]); node!]


0.194009622834

**209** : When unification of two nodes results in a node with an arc with a feature in ifeatures, it yields I because of feature inconsistency.


0.298007236769

**208** : An inhibited feature function is implemented using the gestures field of nodes.



##The Citing Sentences :
As it has been noticed by [Godden 90] and [Kogure 90], the key idea of avoiding "redundant copying" is to do copying lazily.

###The Corpus Reference Sentences :
0.774462138695


**23** : Copying sharable parts is called redundant copying.

0.889102119346


**141** : 5 disables structure sharing, ttowever, this whole copying is not necessary if a lazy evaluation method is used.

0.968214289119


**142** : With such a method, it is possible to delay copying a node until either its own contents need to change (e.g., node G3/Ka c !7>) or until it is found to have an arc (sequence) to a node t, hat needs to be copied (e.g., node X G3/<a c> in Fig.


###Our Reference Sentences :
0.0727466359086

**187** : 2328, 1992 node structure 111=111111110M11= rinIMINI/a set o arc structures 11=121111111= IEZZEINIMINI=ED 011=1111111111=12=11M011â 1 MIIIIIIIIIMIEMIE 1/4=11â¢1111ELIMMTIM 111121MIMICIIMEDIEED Figure 4: Data Structures Function Unify(nodel , nodc2) begin node] := Dereference(nodel); riode2 :-= Dereference(ruxle2); if node] = node then return( node 1); nodel . forward := node2 ; node2.tsymbol := node] .tsurnbol AT node2.tsymbol; if node2.tsymbol = _I_ then return(i) node2.ileatures node] .ifeatures U node2 :ilea tures ; if node2.ifeaturesn { arc. feature I arc E node] .arcs U node .nrcs) 0 then returri(1.); node2.dnodes := node!


0.16846013606

**207** : The function Complemenl_A re S also takes two nodes and gives a set of arcs whose features exist in the first node but not in the second.


0.184935524158

**188** : .dnodes U node2.dnodes; if {nodel , node2} fl node2.dnodes tt then rettirn(..t.); arcpairs := Shared _Arc_Pairs(nodel , node2); for (arc] , arc2) in Â°repairs do begin value := Unify(orcl :value, arc2.value); if value -= then return(Â±); end; arcs := Coroplement_Ares(node I , node!]); node!]


0.194009622834

**209** : When unification of two nodes results in a node with an arc with a feature in ifeatures, it yields I because of feature inconsistency.


0.298007236769

**208** : An inhibited feature function is implemented using the gestures field of nodes.



##The Citing Sentences :
Copying of nodes will be delayed until a destructive change is about to take place.

###The Corpus Reference Sentences :
0.99235650418


**23** : Copying sharable parts is called redundant copying.

0.996278303777


**141** : 5 disables structure sharing, ttowever, this whole copying is not necessary if a lazy evaluation method is used.

0.18054113156


**142** : With such a method, it is possible to delay copying a node until either its own contents need to change (e.g., node G3/Ka c !7>) or until it is found to have an arc (sequence) to a node t, hat needs to be copied (e.g., node X G3/<a c> in Fig.


###Our Reference Sentences :
0.0727466359086

**187** : 2328, 1992 node structure 111=111111110M11= rinIMINI/a set o arc structures 11=121111111= IEZZEINIMINI=ED 011=1111111111=12=11M011â 1 MIIIIIIIIIMIEMIE 1/4=11â¢1111ELIMMTIM 111121MIMICIIMEDIEED Figure 4: Data Structures Function Unify(nodel , nodc2) begin node] := Dereference(nodel); riode2 :-= Dereference(ruxle2); if node] = node then return( node 1); nodel . forward := node2 ; node2.tsymbol := node] .tsurnbol AT node2.tsymbol; if node2.tsymbol = _I_ then return(i) node2.ileatures node] .ifeatures U node2 :ilea tures ; if node2.ifeaturesn { arc. feature I arc E node] .arcs U node .nrcs) 0 then returri(1.); node2.dnodes := node!


0.108917542618

**187** : 2328, 1992 node structure 111=111111110M11= rinIMINI/a set o arc structures 11=121111111= IEZZEINIMINI=ED 011=1111111111=12=11M011â 1 MIIIIIIIIIMIEMIE 1/4=11â¢1111ELIMMTIM 111121MIMICIIMEDIEED Figure 4: Data Structures Function Unify(nodel , nodc2) begin node] := Dereference(nodel); riode2 :-= Dereference(ruxle2); if node] = node then return( node 1); nodel . forward := node2 ; node2.tsymbol := node] .tsurnbol AT node2.tsymbol; if node2.tsymbol = _I_ then return(i) node2.ileatures node] .ifeatures U node2 :ilea tures ; if node2.ifeaturesn { arc. feature I arc E node] .arcs U node .nrcs) 0 then returri(1.); node2.dnodes := node!


0.133659274932

**202** : The function Unify takes two input nodes and puts them in a K.-class by letting one input be the forward field values.


0.134823205943

**208** : An inhibited feature function is implemented using the gestures field of nodes.


0.16846013606

**207** : The function Complemenl_A re S also takes two nodes and gives a set of arcs whose features exist in the first node but not in the second.



##The Citing Sentences :
Kogure uses a revised copynode procedure which maintains copy dependency information in order to avoid immediate copying.

###The Corpus Reference Sentences :
0.948812004997


**23** : Copying sharable parts is called redundant copying.

0.975076042151


**141** : 5 disables structure sharing, ttowever, this whole copying is not necessary if a lazy evaluation method is used.

0.992876457564


**142** : With such a method, it is possible to delay copying a node until either its own contents need to change (e.g., node G3/Ka c !7>) or until it is found to have an arc (sequence) to a node t, hat needs to be copied (e.g., node X G3/<a c> in Fig.


###Our Reference Sentences :
0.0727466359086

**187** : 2328, 1992 node structure 111=111111110M11= rinIMINI/a set o arc structures 11=121111111= IEZZEINIMINI=ED 011=1111111111=12=11M011â 1 MIIIIIIIIIMIEMIE 1/4=11â¢1111ELIMMTIM 111121MIMICIIMEDIEED Figure 4: Data Structures Function Unify(nodel , nodc2) begin node] := Dereference(nodel); riode2 :-= Dereference(ruxle2); if node] = node then return( node 1); nodel . forward := node2 ; node2.tsymbol := node] .tsurnbol AT node2.tsymbol; if node2.tsymbol = _I_ then return(i) node2.ileatures node] .ifeatures U node2 :ilea tures ; if node2.ifeaturesn { arc. feature I arc E node] .arcs U node .nrcs) 0 then returri(1.); node2.dnodes := node!


0.108917542618

**187** : 2328, 1992 node structure 111=111111110M11= rinIMINI/a set o arc structures 11=121111111= IEZZEINIMINI=ED 011=1111111111=12=11M011â 1 MIIIIIIIIIMIEMIE 1/4=11â¢1111ELIMMTIM 111121MIMICIIMEDIEED Figure 4: Data Structures Function Unify(nodel , nodc2) begin node] := Dereference(nodel); riode2 :-= Dereference(ruxle2); if node] = node then return( node 1); nodel . forward := node2 ; node2.tsymbol := node] .tsurnbol AT node2.tsymbol; if node2.tsymbol = _I_ then return(i) node2.ileatures node] .ifeatures U node2 :ilea tures ; if node2.ifeaturesn { arc. feature I arc E node] .arcs U node .nrcs) 0 then returri(1.); node2.dnodes := node!


0.133659274932

**202** : The function Unify takes two input nodes and puts them in a K.-class by letting one input be the forward field values.


0.134823205943

**208** : An inhibited feature function is implemented using the gestures field of nodes.


0.16846013606

**207** : The function Complemenl_A re S also takes two nodes and gives a set of arcs whose features exist in the first node but not in the second.



#analysing the annotation 17
**Not valid annotation**